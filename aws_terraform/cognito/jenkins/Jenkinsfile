pipeline {

  agent any 

  options {
    buildDiscarder(logRotator(numToKeepStr: '3'))
    timestamps()
    timeout(time: 45, unit: 'MINUTES')
  }

  parameters {
    string(name: 'ENVIRONMENT', defaultValue: 'dev', description: 'dev | qa | prod')
    booleanParam(name: 'RUN_APPLY', defaultValue: false, description: 'Run terraform apply?')
    booleanParam(name: 'RUN_DESTROY', defaultValue: false, description: 'Run terraform destroy?')
    string(name: 'ASSUME_ROLE_ARN', defaultValue: '', description: 'Optional: Assume this role before running Terraform')
  }

  environment {
    TF_BACKEND_BUCKET = 'testing-epa-application-bucket19112025'
    TF_BACKEND_REGION = 'ap-south-1'
    TF_BACKEND_KEY_BASE = 'cognito-identity-setup'
    TF_PLAN_FILE = 'tfplan.binary'
    TF_FOLDER = 'aws_terraform/cognito/cog_tf'
    TF_IN_AUTOMATION = 'true'
  }

  stages {
    stage('Checkout Repo') {
      steps {
        checkout scm
        script {
          env.TF_BACKEND_KEY = "${TF_BACKEND_KEY_BASE}/${params.ENVIRONMENT}/terraform.tfstate"
        }
      }
    }
    stage('Terraform Init') {
      steps {
        dir(env.TF_FOLDER) {
          sh '''
            terraform init \
              -backend-config="bucket=${TF_BACKEND_BUCKET}" \
              -backend-config="key=${TF_BACKEND_KEY}" \
              -backend-config="region=${TF_BACKEND_REGION}"
          '''
        }
      }
    }
    stage('Format & Validate') {
       steps {
    dir(env.TF_FOLDER) {
      script {
        // Run terraform fmt -check and capture exit code
        def fmtResult = sh(script: "terraform fmt -check -recursive", returnStatus: true)
        
        if (fmtResult != 0) {
          echo "WARNING: Terraform files are not properly formatted!"
          // Optional: mark the build as unstable but continue
          currentBuild.result = 'UNSTABLE'
        } else {
          echo "Terraform files are properly formatted."
        }

        // Always run validate
        sh "terraform validate"
      }
    }
  }
}
    stage('Plan') {
      steps {
        lock(resource: "tf-${params.ENVIRONMENT}") {
          dir(env.TF_FOLDER) {
            sh '''
              terraform workspace new ${ENVIRONMENT} || terraform workspace select ${ENVIRONMENT}
              terraform plan -out=${TF_PLAN_FILE}
              terraform show -json ${TF_PLAN_FILE} > plan.json
            '''
          }
          archiveArtifacts artifacts: "${env.TF_FOLDER}/plan.json"
        }
      }
    }

    stage('Approval for Production Apply') {
      when {
        expression { params.RUN_APPLY && params.ENVIRONMENT == 'prod' }
      }
      steps {
        input message: "Approve Terraform APPLY for PRODUCTION?"
      }
    }

    stage('Apply') {
      when { expression { params.RUN_APPLY && !params.RUN_DESTROY } }
      steps {
        lock(resource: "tf-${params.ENVIRONMENT}") {
          dir(env.TF_FOLDER) {
            sh '''
              terraform apply -auto-approve ${TF_PLAN_FILE}
            '''
          }
        }
      }
    }

    stage('Destroy (Gated)') {
      when { expression { params.RUN_DESTROY } }

      steps {
        script {
          input message: "CONFIRM DESTROY for ${params.ENVIRONMENT}?"
        }

        lock(resource: "tf-${params.ENVIRONMENT}") {
          dir(env.TF_FOLDER) {
            sh '''
              terraform destroy -auto-approve
            '''
          }
        }
      }
    }
  }

  post {
    always {
      sh '''
        unset AWS_ACCESS_KEY_ID || true
        unset AWS_SECRET_ACCESS_KEY || true
        unset AWS_SESSION_TOKEN || true
      '''
    }
    success { echo "Completed for ${params.ENVIRONMENT}" }
    failure { echo "Pipeline failed. Check logs." }
  }
}



